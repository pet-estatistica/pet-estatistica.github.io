---
title: 'Introdução ao TidyVerse'
author: Caio Gomes Alves
date: '`r Sys.Date()`'
slug: introducao-ao-tidyverse
categories:
  - r
  - dados
  - tidyverse
tags:
  - r
  - blogdown
  - analise
  - dados
description: 'Um minicurso introdutório ao congregado de pacotes mais utilizado para a análise de dados no R : o {tidyverse}'
images:
  - 'img/caio_post/tidyverse.png'
---

```{r setup, include=FALSE}
library(tidyverse)
library(nycflights13)
library(gapminder)
```

## O Pacote Tidyverse

Uma parte extremamente importante na análise de dados envolve a organização e a estruturação dos mesmos, para que possam ser analisados computacionalmente. Mas muitas vezes, os dados que dispomos não estão exatamente do jeito que precisamos, e muito tempo é gasto na retabulação/reestruturação de planilhas e de tabelas (muitas vezes direto no Excel/Libre Office).

Tendo isso em mente, o objetivo deste minicurso é introduzir o pacote TidyVerse, um compilado de 8 diferentes pacotes (ggplot2, tibble, tidyr, readr, purrr, dplyr, stringr e forcats), cada um tratando de um particular aspecto da criação de dados *tidy*.

Grande parte deste minicurso se baseia no livro *R for Data Science*, escrito por Hadley Wickham e Garret Grolemund, disponível gratuitamente (em inglês) no site https://r4ds.had.co.nz/ , ou em versão física (traduzida) para compra em diversos sites. Caso queira verificar algum tópico deste curso de maneira mais profunda, recomendo fortemente dar uma olhada no livro, que com certeza terá mais substância.

### Instalando o TidyVerse

```{r, eval=FALSE}
install.packages("tidyverse")
library(tidyverse)
# ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──
# ✔ ggplot2 3.3.6     ✔ purrr   0.3.4
# ✔ tibble  3.1.8     ✔ dplyr   1.0.9
# ✔ tidyr   1.2.0     ✔ stringr 1.4.1
# ✔ readr   2.1.2     ✔ forcats 0.5.1
# ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
# ✖ dplyr::filter() masks stats::filter()
# ✖ dplyr::lag()    masks stats::lag()
# 
```

Os conflitos que aparecem são devido às funções filter() e lag() estarem disponíveis tanto no pacote dplyr quanto no pacote stats, que faz parte do R base. Nesse caso, as funções pertencentes ao R base são substituídas (mascaradas) pelas suas contrapartes do dplyr, e caso seja necessário utilizá-las, será necessário chamar `r "stats::filter()"` ou `r "stats::lag()"`.

### Bases de Dados Utilizadas

Utilizaremos três bases de dados durante este curso, que serão manipuladas pelas diversas funções do tidyverse. Duas delas (flights e gapminder) fazem parte de pacotes específicos, que devem ser instalados e chamados, e a terceira (diamonds) faz parte da biblioteca básica do R.

```{r, eval = FALSE}
# Instalando os pacotes nycflights e gapminder
install.packages("nycflights13")
install.packages("gapminder")

```

```{r}
# Carregando os respectivos pacotes
library(nycflights13)
library(gapminder)

# Carregaremos os dados para objetos, que serão utilizados durante o minicurso
voos <- nycflights13::flights
paises <- gapminder::gapminder
diamantes <- diamonds
```

Caso queira verificar a documentação por trás de cada uma dessas bases de dados, utilize ?flights , ?gapminder e ?diamonds.

## Organizando dados com tibbles e DplyR

### A Base nycflights13

Os dados carregados pelo pacote nycflights13::flights são referentes a todos os voos que passaram pelo aeroporto de Nova York no ano de 2013, com diversas informações, como data (dividida em ano, mês e ano), horários de saída e chegada, atraso, destino/origem do voo, dentre outros. Vamos dar uma olhada nessa base:

```{r}
voos
```

É possível perceber uma diferença notável na estrutura desses dados: eles não estão organizados em um data frame, mas em um objeto da classe tibble. O tibble é um data frame, porém com algumas diferenças fundamentais: ele não converte strings em fatores e o seu método de impressão por padrão mostra apenas as dez primeiras linhas, e apenas as colunas que cabem na tela. Além disso, é possível verificar o tipo dos dados de cada uma das colunas a partir das letras que aparecem ao lado de cada nome:

* **int** é para inteiros;
* **dbl** é para *doubles*, ou números reais;
* **chr** é para caracteres, ou *strings*;
* **dttm** é para caracteres de data-tempo (data + horário);
* **lgl** é para vetores lógicos (que só possuem TRUE ou FALSE);
* **fctr** é para fatores (variáveis categóricas com valores fixos);
* **date** para datas (sem horário).

## O Básico do Dplyr

O dplyr permite que a maioria dos problemas de manipulação de dados sejam resolvidos de maneira simples, utilizando cinco funções principais e uma função auxiliar:

* **filter()** para filtrar somente as linhas necessárias para uma análise;
* **arrange()** para reorganizar a ordem das linhas;
* **select()** para selecionar as variáveis por meio dos nomes;
* **mutate()** para criar novas variáveis a partir das já existentes;
* **summarise()** para criar resumos de variáveis;
* **group_by()** para agrupar os dados e mudar a forma estrutural da análise.

Essas seis funções são o "feijão-com-arroz" da manipulação de dados com o dplyr, e fornecem uma poderosa ferramenta que é utilizada em um *workflow* dinâmico e simples de entender:

1. O primeiro argumento de todas essas funções deve ser um data frame;
2. Os argumentos subsequentes definem o que deve ser feito com esse data frame;
3. O resultado da função é um data frame.

Com isso, a composição das funções fica fácil e intuitiva de se fazer.

## Filtrando Linhas com filter()

A função filter() é utilizada para filtrar somente as linhas de um data frame em que seus valores obedeçam uma expressão. Por exemplo, digamos que queremos todos os dados de voos que ocorreram no dia 05 de maio da base flights. Podemos utilizar o filter() para tal:

```{r}
filter(voos, day == 5, month == 5)
```

Perceba que somente retornaram as linhas em que o dia = 5 e que o mês = 5, ou seja, 912 linhas ao todo. Note também que o dplyr retornou um data frame, mas que os dados originais não foram alterados. Caso queiramos salvar esse novo conjunto de dados, devemos atribuir ele para um objeto:

```{r}
mai5 <- filter(voos, day == 5, month == 5)

# O dplyr só imprime os dados ou os atribui a um objeto.
# Caso queira fazer ambos, é só envolver a atribuição entre parenteses:

(dez25 <- filter(voos, day == 25, month == 12))
```

Em todos os casos, o primeiro argumento da função foi a nossa base de dados (voos), e os argumentos seguintes são os filtros que queremos aplicar, utilizando comparações com os nomes das colunas. Podemos atribuir quantos filtros quisermos, cada um separado por vírgula.

### Operações lógicas e de comparação

Para que possamos utilizar o filter() de maneira eficiente, é necessário saber como selecionar as observações com operadores de comparação com auxílio de operadores lógicos. Para isso, usamos dois caracteres especiais, reservados para operadores booleanos: | e &:

A expressão & é equivalente ao *and*, e retorna TRUE caso todos os valores sejam verdadeiros, e FALSE caso contrário. A expressão | é equivalente ao *or*, e retorna TRUE caso algum dos valores seja verdadeiro. Por exemplo, vamos selecionar todos os voos nos meses de novembro e dezembro:

```{r}
filter(voos, month == 11 | month == 12)
```

Aqui, estamos filtrando as linhas em que **month == 11** ou **month == 12**. Ao invés de utilizar essa notação, poderíamos utilizar a função %in%, que compara os valores com um vetor de possibilidades, um a um. A expressão seria simplificada para:

```{r}
filter(voos, month %in% c(11,12))
```

Podemos também operar com a negação de um opereador lógico, invertendo o mesmo com !, que é equivalente ao *not*. Lembremos da Lei de Morgan: !(x & y) é o mesmo que !x | !y, e !(x | y) é o mesmo que !x & !y. Digamos que queremos encontrar todos os voos que não são dos meses de janeiro e fevereiro. Podemos fazer da seguinte maneira:

```{r}
# Podemos filtrar mês a mês:
nao_jan_fev1 <- filter(voos, month == 3|month == 4|month == 5|month == 6|month == 7|month == 8|month == 9|month == 10|month == 11|month == 12)

# Podemos filtrar com %in%:
nao_jan_fev2 <- filter(voos, month %in% c(3:12))

# Podemos filtrar com a negação:
nao_jan_fev3 <- filter(voos, !(month %in% c(1,2)))
```


Um problema que pode ocorrer são dados faltantes (NAs no R). Há um problema muito sério na análise de dados com os NAs: eles são infectantes. Isso ocorre porque a maioria das operações quando aplicadas a NA retornam NA:

```{r, warning=FALSE}
# Operadores algébricos:
3 + NA
5 - NA
3 * NA

# Operadores de comparação:
NA == 1
NA > 1
NA < 1

# Talvez o mais confuso seja o seguinte:
NA == NA
```

Em seu livro, Hadley usa uma boa analogia para entender as operações com NAs:

```{r}
# x é a idade de João. Não sabemos a sua idade:
x <- NA

# y é a idade de Maria. Também não sabemos a idade dela:
y <- NA

# João é mais velho que Maria?
x > y

# João é mais novo que Maria?
x < y

# João tem a mesma idade que Maria?
x == y

# Em todos os casos, a resposta é a mesma: NÃO SEI
# Para lidarmos com NAs, podemos usar a função is.na()
# Que retorna TRUE caso seja NA, e FALSE caso contrário
is.na(x)

# Muitas funções tem embutidos argumentos específicos para lidar com NAs
# Na função mean(), por exemplo, é usado na.rm = TRUE
mean(c(1,2,3,NA,4), na.rm = TRUE)
```

A função filter() por padrão só mantém as linhas em que as comparações retornam TRUE, excluindo quem retornar FALSE ou NA. Para contornar isso, podemos utilizar a função is.na(), que retorna TRUE caso o valor seja NA. Por exemplo, há voos que tem tempo no ar (air_time) vazio, ou seja, voos que foram cancelados. Para selecionar somente eles, usaremos:

```{r}
(cancelados <- filter(voos, is.na(air_time)))
```

## Ordenando linhas com arrange()

A função arrange() funciona de maneira similar ao filter(), mas reorganiza as linhas mudando a ordem delas, ao invés de selecioná-las. Ela recebe um data frame como primeiro argumento e os nomes das colunas que devem ser ordenadas. Se mais de um nome for passado, cada coluna a mais sevirá como fator de desempate para as colunas anteriores:

```{r}
# Vamos organizar a base em ordem cronológica
arrange(voos, year, month, day)
```

Aqui, foram reordenadas as linhas de modo que o ano seja colocado em ordem crescente. Após isso, foram reorganizados para que o mês seja colocado em ordem crescente. Ao final, foram reorganizados de forma a deixar os dias em ordem crescente. Com isso, a base foi reordenada por ordem cronológica (1/1/2013 -> 2/1/2013 -> 3/1/2013 -> ...). Caso queira deixar em ordem decrescente, use desc():

```{r}
# Vamos organizar por atraso de saída (dep_delay) decrescente
# Assim, vemos os voos que mais atrasaram:
arrange(voos, desc(dep_delay))
```

## Selecionando colunas com select()

Normalmente as bases de dados são conjunto com dezenas até centenas de variáveis. E muitas vezes, apenas algumas dessas variáveis é de nosso interesse, de forma que é desnecessário utilizar todas elas em nossa análise. Para isso, vamos utilizar a função select(), que seleciona somente um subconjunto de colunas da base:

```{r}
# Vamos selecionar somente as colunas com datas:
select(voos, year, month, day)

# Podemos selecionar também com a posição das colunas:
select(voos, c(1:3))

# Além disso, podemos trabalhar com conjuntos:
select(voos, dep_time:arr_time)

# Podemos excluir colunas com -(nome_coluna)
select(voos,-(year:day))
```

Há várias funções que podemos utilizar com o select(), dentre elas as mais utilizadas são:

* **starts_with("abc")** combina nomes que começam com "abc";
* **ends_with("abc")** combina nomes que terminam com "abc";
* **contains("abc")** combina nomes que contém "abc";
* **matches("(.)\\1")** combina nomes que contenham uma expressão regular (expressões regulares serão abordadas mais para frente);
* **everything()** seleciona todas as colunas restantes de uma base.

```{r}
# Por exemplo, vamos selecionar todas as colunas que começam com dep
# Essas colunas se referem à saída dos voos:
select(voos, starts_with("dep"))

# Podemos reorganizar a ordem das variáveis com everything():
select(voos, time_hour, distance, everything())

# Podemos renomear uma coluna com a função select(), mas não é recomendado
# Para isso, é melhor usar a função rename()
rename(voos, ano = year, mes = month, dia = day)
```

## Criando novas variáveis com mutate()

Além de selecionarmos colunas, muitas vezes precisamos adicionar colunas com funções de outras variáveis existentes. Para isso, temos a função mutate(), que cria colunas no final da base de dados, usando os valores de colunas já existentes:

```{r}
# Vamos criar uma coluna com a velocidade media do voo
# Dividindo a coluna de distancia pelo tempo de voo:
mutate(voos, velocidade_media = distance/air_time)
```

Como a função mutate() coloca a nova coluna no final, não conseguimos ver a mesma, já que temos muitas colunas. Para isso, vamos usar a função select() e depois usar a mutate():

```{r}
voos2 <- select(voos, distance, air_time)

mutate(voos2, velocidade_media = distance/air_time)
```

Para fazer a transformação anterior, foi necessário criar um objeto intermediário (voos2) para ser usado depois. Essa prática não é recomendada, uma vez que utiliza muita memória de forma desnecessária. Ao invés disso, podemos fazer uma composição de funções. Como a saída de todas as funções do dplyr são data frames, podemos compor as funções:

```{r}
# Mesma transformação de antes:
mutate(select(voos, distance, air_time),velocidade_media = distance/air_time)
```

O problema agora é que as funções são avaliadas de dentro para fora, de maneira contraintuitiva. Caso diversas operações fossem necessárias, seria fácil se perder no meio de um sem-fim de parenteses. Para resolver isso, o tidyverse é todo integrado em uma função especial do pacote magrittr: o pipe.

### O pipe

O pipe, denotado pelo caractere %>% serve como uma operação especial que "pega" o que está antes dele, e passa como primeiro argumento para a função após ele. Vejamos de maneira prática:

```{r}
x <- c(1,2,3,4,5,6)
# Digamos que queremos calcular a média desses valores

# "Normalmente", usamos a seguinte notação:
mean(x)

# Usando o pipe, teríamos:
x %>% mean()
```

Vendo o exemplo acima, não aparenta haver motivo para usar o pipe. Mas, o seu verdadeiro potencial reside no encadeamento de funções:

```{r}
# Digamos que queremos filtrar os voos que aconteceram no mês de Maio
# Depois queremos selecionar somente as colunas origin, dest, air_time e distance
# Por último, vamos criar uma nova coluna com a velocidade média

# Vamos começar criando variáveis intermediárias:
voos2 <- filter(voos, month == 5)
voos3 <- select(voos2, origin, dest, air_time, distance)
voos4 <- mutate(voos3, velocidade_media = distance/air_time)

voos4

# Vejam quantas variáveis desnecessárias foram criadas
# Podemos fazer como antes, e compor funções:
voos2 <- mutate(select(filter(voos,month == 5),origin, dest, air_time, distance), velocidade_media = distance/air_time)

voos2

# O resultado é o mesmo, porém a função criada é muito complexa para ser lida
# Pois as operações ocorrem de dentro para fora. Isso complica o debugging
# Caso ocorram erros. Vejamos como seria com o pipe:
voos2 <- voos %>% 
    filter(month == 5) %>% 
    select(origin, dest, air_time, distance) %>% 
    mutate(velocidade_media = distance/air_time)

voos2

# Percebam que as operações foram realizadas na ordem em que foram aparecendo.
```

Como visto, o pipe auxilia no encadeamento de transformações sucessivas de funções, sem que seja necessário criar objetos intermediários desnecessários. E ele funciona especialmente bem com as funções do dplyr, pois todas elas tem como entrada um data frame e como saída outro data frame. Com isso, podemos fazer diversas transformações seguidas, seguindo a ordem conforme formos colocando elas.

A partir daqui, todos os exemplos serão utilizando pipe, então caso ainda encontre alguma dificuldade, recomendo ler a documentação do pacote magrittr, disponível em https://magrittr.tidyverse.org/ , além do capítulo 18 do livro *R for Data Science*, disponível em https://r4ds.had.co.nz/pipes.html .

### Funções úteis com o mutate()

Muitas funções podem ser utilizada em conjunto com a função mutate(), para extrair informação de suas variáveis. Alguns dos exemplos mais comuns são:

* **Operações aritméticas (+,-,*,/,^)** - Podemos somar, subtrair, multiplicar ou dividir linhas, umas pelas outras, ou realizar essas operações com números (constantes) ou vetores (seguindo a regra da reciclagem do R);
* **Aritmética modular** - As operações resto (%%) e divisão inteira (%/%)
